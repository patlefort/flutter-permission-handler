#!/usr/bin/env bash

set -euo pipefail
shopt -s inherit_errexit

ns=$1
cmd=$2

case $cmd in
	netns)
		
		case $3 in
			create)
				echo "Creating network namespace $ns."

				# Setup network namespace and lo interface.
				# It is meant to be run inside an anonymous network namespace of a systemd service.
				
				ip link set lo up
				
				flock --no-fork -- /var/run/netns.lock ip netns add $ns
				umount /var/run/netns/$ns
				mount --bind /proc/self/ns/net /var/run/netns/$ns
				
				;;

			delete)
				echo "Deleting network namespace $ns."

				flock --no-fork -- /var/run/netns.lock ip netns delete $ns

				;;
			*)
				>&2 echo 'Invalid command.'
				exit 1
				;;
		esac

		;;

	macvlan)

		case $3 in
			create)
				# Read config
				if [[ ! -f /etc/netns-helper/ns/$ns-macvlan.conf ]]; then
					>&2 echo "File /etc/netns-helper/ns/$ns-macvlan.conf not found, exiting."
					exit 1
				fi
				
				source /etc/netns-helper/ns/$ns-macvlan.conf
				
				echo "Creating macvlan interface in $ns with $parent_if."

				# Setup macvlan interface and link it to parent interface.
				ip link add nm_$ns link $parent_if type macvlan mode ${macvlan_mode:-bridge} || \
					{
						>&2 echo 'Failed to create macvlan interface.'
						exit 1
					}
				
				ip link set nm_$ns netns $ns || \
					{
						>&2 echo 'Failed to add macvlan to network namespace.'
						ip link delete nm_$ns
						exit 1
					}
				
				macvlan_failed()
				{
					# Delete interface on failure
					ip netns exec $ns ip link delete nm_$ns
				}
					
				trap 'macvlan_failed' ERR
				
				if [[ -v mac && -n "$mac" ]]; then
					ip netns exec $ns ip link set nm_$ns address $mac
				fi
				
				# Privacy extensions
				if [[ -v privacy_ext && -n "$privacy_ext" ]]; then
					ip netns exec $ns sysctl -w net.ipv6.conf.nm_$ns.use_tempaddr=$privacy_ext
				fi
				
				# Run preup script
				if [[ -x /etc/netns-helper/ns/$ns-macvlan-preup ]]; then
					ip netns exec $ns /etc/netns-helper/ns/$ns-preup nm_$ns
				fi
				
				ip netns exec $ns ip link set nm_$ns up
				
				# Configure macvlan interface
				if [[ -v ipaddr4 && -n "$ipaddr4" ]]; then
					ip netns exec $ns ip address add $ipaddr4 dev nm_$ns
				fi
				
				if [[ -v default_gateway4 && -n "$default_gateway4" ]]; then
					ip netns exec $ns ip route add default via $default_gateway4 dev nm_$ns onlink \
						${gateway_metric:+metric $gateway_metric}
				fi
				
				if [[ -v ipaddr6 && -n "$ipaddr6" ]]; then
					ip netns exec $ns ip -6 address add $ipaddr6 dev nm_$ns
				fi
				
				if [[ -v default_gateway6 && -n "$default_gateway6" ]]; then
					ip netns exec $ns ip -6 route add default via $default_gateway6 dev nm_$ns onlink \
						${gateway_metric:+metric $gateway_metric}
				fi
				
				echo 'Macvlan interface:'
				ip netns exec $ns ip link show nm_$ns

				mkdir -p /run/netmachine/$ns
				
				# Run postup script
				if [[ -x /etc/netns-helper/ns/$ns-macvlan-postup ]]; then
					ip netns exec $ns /etc/netns-helper/ns/$ns-postup nm_$ns
				fi

				;;
			delete)
				echo "Deleting macvlan interface in namespace $ns."
				ip netns exec $ns ip link delete nm_$ns

				;;
			*)
				>&2 echo 'Invalid command.'
				exit 1
				;;
		esac

		;;
		
	nat)

		case $3 in
			create)
				# Read config
				if [[ ! -f /etc/netns-helper/ns/$ns-nat.conf ]]; then
					>&2 echo "File /etc/netns-helper/ns/$ns-nat.conf not found, exiting."
					exit 1
				fi
				
				source /etc/netns-helper/ns/$ns-nat.conf
				
				echo "Creating veth interface in $ns."

				# Create a veth pair
				ip link add nv_$ns type veth peer name nvp_$ns
				
				veth_failed()
				{
					# Delete interface on failure
					ip link delete nv_$ns
				}
				
				trap 'veth_failed' ERR
				
				ip link set nvp_$ns netns $ns
				
				# Configure veth pair
				if [[ -v ipaddr4 && -n "$ipaddr4" ]]; then
					ip address add $ipaddr4 dev nv_$ns
				fi
				if [[ -v ipaddr6 && -n "$ipaddr6" ]]; then
					ip -6 address add $ipaddr6 dev nv_$ns
				fi
				
				ip link set nv_$ns up
				
				if [[ -v ipaddr4_peer && -n "$ipaddr4_peer" ]]; then
					ip netns exec $ns ip address add $ipaddr4_peer dev nvp_$ns
				fi
				if [[ -v ipaddr6_peer && -n "$ipaddr6_peer" ]]; then
					ip netns exec $ns ip -6 address add $ipaddr6_peer dev nvp_$ns
				fi
				
				ip netns exec $ns ip link set nvp_$ns up
				
				# Configure firewall rules and set default route
				nft add table inet nh_nat_$ns
				
				if [[ -v parent_if && -n "$parent_if" ]]; then
					nft add chain inet nh_nat_$ns postrouting "{ type nat hook postrouting priority 0; }"
					nft add chain inet nh_nat_$ns forward "{ type filter hook forward priority 0; }"
					nft add rule inet nh_nat_$ns forward iifname "$parent_if" oifname "nv_$ns" accept
					nft add rule inet nh_nat_$ns forward iifname "nv_$ns" oifname "$parent_if" accept
				fi
				
				if [[ -v ipaddr4 && -n "$ipaddr4" ]]; then
					ip netns exec $ns ip route add default via ${ipaddr4%\/*} ${gateway_metric:+metric $gateway_metric}
					nft add rule inet nh_nat_$ns postrouting oifname "$parent_if" ip saddr $ipaddr4 masquerade
				fi
				if [[ -v ipaddr6 && -n "$ipaddr6" ]]; then
					ip netns exec $ns ip -6 route add default via ${ipaddr6%\/*} ${gateway_metric:+metric $gateway_metric}
					nft add rule inet nh_nat_$ns postrouting oifname "$parent_if" ip6 saddr $ipaddr6 masquerade
				fi
				
			;;
			
			delete)
				echo "Deleting veth interface in namespace $ns."
				ip link delete nv_$ns || true
				nft delete table inet nh_nat_$ns
				
			;;
		esac
		
	;;
	
	bridge)
		
		case $3 in
			create)
				# Read config
				if [[ ! -f /etc/netns-helper/ns/$ns-bridged.conf ]]; then
					>&2 echo "File /etc/netns-helper/ns/$ns-bridged.conf not found, exiting."
					exit 1
				fi
				
				source /etc/netns-helper/ns/$ns-bridged.conf
			
				echo "Creating veth interface in $ns."
				
				# Create a veth pair
				ip link add nb_$ns type veth peer name nbp_$ns
				
				veth_failed()
				{
					# Delete interface on failure
					ip link delete nb_$ns
				}
				
				trap 'veth_failed' ERR
				
				# Configure veth pair
				ip link set nbp_$ns netns $ns
				
				if [[ -v mac && -n "$mac" ]]; then
					ip netns exec $ns ip link set nbp_$ns address $mac
				fi
				
				#if [[ -v ipaddr4 && -n "$ipaddr4" ]]; then
				#	ip address add $ipaddr4 dev nb_$ns
				#fi
				#if [[ -v ipaddr6 && -n "$ipaddr6" ]]; then
				#	ip -6 address add $ipaddr6 dev nb_$ns
				#fi
				
				ip link set nb_$ns up
				
				if [[ -v ipaddr4_peer && -n "$ipaddr4_peer" ]]; then
					ip netns exec $ns ip address add $ipaddr4_peer dev nbp_$ns
				fi
				if [[ -v ipaddr6_peer && -n "$ipaddr6_peer" ]]; then
					ip netns exec $ns ip -6 address add $ipaddr6_peer dev nbp_$ns
				fi
				
				ip netns exec $ns ip link set nbp_$ns up
				
				if [[ -v default_gateway4 && -n "$default_gateway4" ]]; then
					ip netns exec $ns ip route add default via $default_gateway4 dev nb_$ns onlink \
						${gateway_metric:+metric $gateway_metric}
				fi
				
				if [[ -v default_gateway6 && -n "$default_gateway6" ]]; then
					ip netns exec $ns ip -6 route add default via $default_gateway6 dev nb_$ns onlink \
						${gateway_metric:+metric $gateway_metric}
				fi
				
				ip link set nb_$ns master $bridge_interface
				echo "Interface added to bridge $bridge_interface."
			
			;;
			
			delete)
				echo "Deleting veth interface in namespace $ns."
				ip link delete nb_$ns
				
			;;
		esac
	
	;;
		
	postup)
		
		if [[ -x /etc/netns-helper/ns/$ns-postup ]]; then
			/etc/netns-helper/ns/$ns-postup
		fi
		
		;;
		
	*)
		>&2 echo 'Invalid command.'
		exit 1
		;;
esac
