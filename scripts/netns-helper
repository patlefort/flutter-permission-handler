#!/bin/bash

set -euo pipefail
shopt -s inherit_errexit

avail_features=(dhcp dhcp6 macvlan)

opt_overwrite=no
opt_parent_if=
opt_now=no
opt_mac=
opt_help=

pargs=()
while [[ $# -gt 0 ]]; do
	if [[ $1 == '-'* ]]; then
		case "$1" in
			--parent_if)
				opt_parent_if="$2"
				shift 2
			;;
			
			--mac)
				opt_mac="$2"
				shift 2
			;;
			
			--overwrite)
				opt_overwrite=yes
				shift 1
			;;
			
			--now)
				opt_now=yes
				shift 1
			;;
			
			--help)
				opt_help=yes
				shift 1
			;;
			
			*)
				>&2 echo 'Invalid option.'
				exit 1
			;;
		esac
	else
		pargs+=($1)
		shift 1
	fi
done

if [[ "$opt_help" == 'yes' ]]; then
	
	cat <<-EOF
		Switches:
		  --now                        Start, restart or stop services now.
		  --overwrite                  Overwrite config with new config if applicable to feature.
		  --parent_if <interface>      Parent interface for macvlan.
		  --mac <mac address>          MAC address of macvlan interface.
		
		Commands:
		  enable <namespace> [<list of features>]
		  disable <namespace> [<list of features>]
			purge <namespace>
		  add-service <service> <namespace>
		  remove-service <service>
		  status [<namespace>]
		  start|restart|stop [<namespace>]
			addr [<namespace>]
			route [<namespace>]
			rules [<namespace>]
			
		Features:
		  dhcp                         Start a dhcp client inside namespace.
		  dhcp6                        Start a dhcpv6 client inside namespace.
		  macvlan                      Create a macvlan interface inside namespace.
	EOF
	
	exit
	
fi

flags=()
if [[ "$opt_now" == 'yes' ]]; then flags+=(--now); fi

tput_checked()
{
	tput "$@" 2>/dev/null || true
}
ocol_label="$(tput_checked setaf 3)"
ocol_sublabel="$(tput_checked setaf 5)"
ocol_reset="$(tput_checked sgr0)"

echo_title()
{
	echo
	echo -e " - ${ocol_label}$1${ocol_reset} - "
	echo
}

echo_subtitle()
{
	echo -e "  [${ocol_sublabel}$1${ocol_reset}]"
}

read_service()
{
	service="$1"
	
	[[ -n "$service" ]] || \
		{
			>&2 echo 'No service given.'
			exit 1
		}
	
	if [[ $service != *.service ]]; then
		service="${service}.service"
	fi

	[[ -n $(systemctl list-unit-files --full --plain --all --no-legend --type service "$service") ]] || \
		{
			>&2 echo "Service \`$service\` not found."
			return 1
		}
}

feature_is_valid()
{
	for f in ${avail_features[@]}; do [[ "$f" == "$1" ]] && return 0; done
	return 1
}

add_features()
{
	local NS=$1
	shift 1
	
	for feature in "$@"; do
		feature_is_valid "$feature" || 
			{
				>&2 echo "Invalid feature \`$feature\`."
				return 1
			}
	done
	
	for feature in "$@"; do
		case "$feature" in
			macvlan)
				if [[ "$opt_overwrite" == 'yes' || ! -f "/etc/netns-helper/ns/$NS-macvlan.conf" ]]; then
					[[ -n "$opt_parent_if" ]] || \
						{
							>&2 echo "The parent interface of the macvlan interface must be specified with option \`--parent_if <interface>\`."
							exit 1
						}
						
					[[ -f "/etc/netns-helper/ns/$NS-macvlan.conf" ]] && \
						echo "Configuration file \`/etc/netns-helper/ns/$NS-macvlan.conf\` overwritten."
						
					umask 022
					cat > "/etc/netns-helper/ns/$NS-macvlan.conf" <<- EOF
						PARENT_IF="$opt_parent_if"
						MAC=$opt_mac
					EOF
				else
					[[ -f "/etc/netns-helper/ns/$NS-macvlan.conf" ]] && \
						echo "Configuration file \`/etc/netns-helper/ns/$NS-macvlan.conf\` already exists and will not be overwritten."
				fi
			;;
		esac
		
		systemctl enable netns-helper-$feature@$NS.service "${flags[@]}"
	done
}

get_namespaces()
{
	local ns=${1:-}
	
	if [[ -z $ns ]]; then
		namespaces=$(systemctl list-units --type target "netns-helper@*.target" --all --no-legend --plain --full \
			| sed -r 's/^(\s*)netns-helper@(\S+)\.target(.*)/\2/')
	else
		namespaces=($ns)
	fi
}

case ${pargs[0]:-} in
	add-service)
		read_service "${pargs[1]:-}"
		ns=${pargs[2]:-}
		
		[[ -n "$ns" ]] || \
			{
				>&2 echo 'No namespace given.'
				exit 1
			}
		
		umask 022
		
		mkdir -p "/etc/systemd/system/$service.d"
		cat > "/etc/systemd/system/$service.d/netns-helper.conf" <<- EOF
			[Unit]
			After=netns-helper@${ns}.target
			Requisite=netns-helper@${ns}.target
			PartOf=netns-helper@${ns}.target
			JoinsNamespaceOf=netns-helper@${ns}.service
			ConditionPathExists=/var/run/netns/${ns}

			[Service]
			PrivateNetwork=true

			BindPaths=-/etc/netns/${ns}/resolv.conf:/etc/resolv.conf
			BindPaths=-/etc/netns/${ns}/nsswitch.conf:/etc/nsswitch.conf
		EOF
		
		systemctl daemon-reload
		
		if [[ "$opt_now" == 'yes' ]]; then
			systemctl restart $service
		fi
		
		echo "Service \`$service\` added to network namespace \`$ns\`."
	;;
	
	remove-service)
		read_service "${pargs[1]}"
		
		rm -f "/etc/systemd/system/$service.d/netns-helper.conf"
		
		systemctl daemon-reload
		
		if [[ "$opt_now" == 'yes' ]]; then
			systemctl restart $service
		fi
		
		echo "Service \`$service\` removed from network namespace."
	;;
	
	enable)
		ns=${pargs[1]:-}
		
		[[ -n "$ns" ]] || \
			{
				>&2 echo 'No namespace given.'
				exit 1
			}
		
		systemctl enable netns-helper@$ns.service
		
		add_features $ns "${pargs[@]:2}"
		
		systemctl enable netns-helper@$ns.target "${flags[@]}"
	;;
	
	disable)
		ns=${pargs[1]:-}
		
		[[ -n "$ns" ]] || \
			{
				>&2 echo 'No namespace given.'
				exit 1
			}
			
		features=(${pargs[@]:2})
		
		if [[ ${#features[@]} == 0 ]]; then
			echo "Disabling namespace \`$ns\`..."
			systemctl disable netns-helper@$ns.target "${flags[@]}"
		else
			for feature in ${features[@]}; do
				echo "Disabling feature \`$feature\` in \`$ns\`..."
				systemctl disable netns-helper-$feature@$ns.service "${flags[@]}"
			done
		fi
	;;
	
	purge)
		ns=${pargs[1]:-}
		
		[[ -n "$ns" ]] || \
			{
				>&2 echo 'No namespace given.'
				exit 1
			}
		
		echo "Purging namespace \`$ns\`..."
		
		systemctl disable netns-helper@$ns.target "${flags[@]}"
		systemctl disable netns-helper@$ns.service "${flags[@]}"
		
		for feature in ${avail_features[@]}; do
			systemctl disable netns-helper-$feature@$ns.service "${flags[@]}"
		done
	;;
	
	status)
		get_namespaces ${pargs[1]:-}
		
		for n in $namespaces; do
			echo_title $n
			systemctl list-dependencies netns-helper@$n.target
		done
	;;
	
	start)
		get_namespaces ${pargs[1]:-}
		
		for n in $namespaces; do
			echo "Starting namespace \`$n\`..."
			systemctl start netns-helper@$n.target
		done
	;;
	
	stop)
		get_namespaces ${pargs[1]:-}
		
		for n in $namespaces; do
			echo "Stopping namespace \`$n\`..."
			systemctl stop netns-helper@$n.target
		done
	;;
	
	restart)
		get_namespaces ${pargs[1]:-}
		
		for n in $namespaces; do
			echo "Restarting namespace \`$n\`..."
			systemctl restart netns-helper@$n.target
		done
	;;
	
	addr)
		get_namespaces ${pargs[1]:-}
		
		for n in $namespaces; do
			echo_title $n
			ip netns exec $n ip addr
		done
	;;
	
	route)
		get_namespaces ${pargs[1]:-}
		
		for n in $namespaces; do
			echo_title $n
			
			echo_subtitle "IPv4"
			ip netns exec $n ip route
			
			echo_subtitle "IPv6"
			ip netns exec $n ip -6 route
		done
	;;
	
	rules)
		get_namespaces ${pargs[1]:-}
		
		for n in $namespaces; do
			echo_title $n
			
			echo_subtitle "IPv4"
			ip netns exec $n iptables --list-rules
			
			echo_subtitle "IPv6"
			ip netns exec $n ip6tables --list-rules
		done
	;;
	
	list)
		systemctl list-units --all --type target 'netns-helper*'
	;;
	
	*)
		>&2 echo 'Invalid command.'
		exit 1
	;;
esac
